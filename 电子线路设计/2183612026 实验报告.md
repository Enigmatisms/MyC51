





![](C:\Users\15300\Desktop\数电实验\电子线路设计\图片1.png)





<center><font size=7 face="微软雅黑"><b> 电 子 线 路 设 计 实 验 报 告 </font></center></centerb>

---

<center> 自动化84 何千越 2183612026 </center>

<center> 2020.10.25 </center>



<div style="page-break-after: always;"></div>

<font size=6 face="微软雅黑"><b>目录</b>(点击导航)</font>

<span id="tophead">

</span>

---

[toc]


<div style="page-break-after: always;"></div>

---

## I. 设计一 模拟微信

---

#### 一、组合功能介绍

##### 1.1.0 框架与流程图

![](C:\Users\15300\Desktop\数电实验\电子线路设计\sim.png)

<center>模块框架图</center>

![](C:\Users\15300\Desktop\数电实验\电子线路设计\power.png)

<center>流程示意图</center>

##### 1.1.1 密码解锁

| <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\pass.JPG" style="zoom:50%;" /> | <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\pass2.JPG" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                         提示输入密码                         |                         密码输入错误                         |

​		上电开机时，需要输入密码才能进入“模拟微信”主程序。密码默认为 123456789，使用软件进行设置，内部没有修改密码的程序（因为本身不属于“模拟微信”的重点）。输入错误显示：Incorrect Input，并清空输入区。输入区中，只有<u>**输入的最后一位**</u>会被显示，其余均被显示成"*"。密码输入支持0~9十位数字 + 26个字母大小写组合，以及4个符号“，.  !  ?”以及空格。

​		三次输入密码将导致程序锁死，有关提示音的内容，请看点击->[【蜂鸣器】](#wechatBuzzer). 输入正确则可进入主程序。

##### 1.1.2 串口消息收发

​		本功能是“模拟微信”的主要功能

<img src="C:\Users\15300\Desktop\数电实验\电子线路设计\wechat.JPG" style="zoom:50%;" />

​		为了尽可能“模拟微信”，之前的密码输入环节模拟的是手机的锁屏界面，而打开锁屏之后直接进入聊天框。我方（主机）发送消息时，最下方一行为我方的输入框（就像手机的聊天输入框）。而我方发送的消息会显示在靠右的位置，对方（从机）发送的消息会显示在靠左的位置，并且对方在发送消息时，消息不会显示在输入框上（就像正常聊天时，我们只能看到对方发送了什么，看不到对方正在输入什么）。并且，消息存在滚动刷新方式。当存在新消息时，历史消息会向上滚动。这都尽可能模拟了实际聊天时的情况。

​		顶部栏显示的则是“微信”软件的版本号。消息的发送使用的是单片机之间的串口通信。

##### 1.1.3 矩阵键盘响应

​		有关矩阵键盘的硬件原理图，可以查看：

- 附录 设计一 原理图

- 设计一的硬件实现部分

  在基本功能介绍中就不放出原理图了。矩阵键盘可以输入：

- 0~9 10个阿拉伯数字
- A~Z大小写输出
- 大写锁开关（CAP）
- 空格（SPACE）
- 退格（DEL）
- 发送 或是 确定输入密码（ENTER）
- 大写锁开启后，部分数字将变为符号输入（比如0~4）

<span id="wechatBuzzer">

##### 1.1.4 蜂鸣器与数码管

​		蜂鸣器在三种情况下会发出声音：

- 在锁屏界面（密码输入）中，密码的错误输入将存在提示音（音调从高到低，给人一种“沮丧感”）

- 在锁屏界面中，密码输入正确将存在提示音（音调较为欢快）

- 在消息收发界面中，当对方发送消息被我方接收后会有提示音（模拟手机的消息提示音）

  数码管（BCD码四引脚）接在从机上，作用是：<u>从机发送消息进行计数。由于只使用一个BCD数码管，最多计数10次，次数更高将会变为0，从新开始计数</u>

</span>

---

#### 二、硬件实现

##### 1.2.1 串口收发

​		![](C:\Users\15300\Desktop\数电实验\电子线路设计\rtx.JPG)

​		如上图所示，左边的单片机为“从机”，右边的单片机为“主机”（**主机需要连接显示屏进行输出，并且多了密码以及蜂鸣器功能**）。由于我们只需要实现从机到主机的消息发送，故<b><font face="微软雅黑">从机P3.0 RXD</font></b>将不连接<b><font face="微软雅黑">主机P3.1 TXD</font></b>（主机没有消息发送需求）。而为了简化软件编程，使主机不需要软件判定是否存在消息，我们使用<b><font face="微软雅黑">从机P3.2 ${\overline {INT0}}$连接到主机对应端口</font></b>，当从机发送消息时，主机${\overline {INT0}}$将会收到一个低脉冲，引起下降沿中断触发，导致主机中断进入消息接收状态。

​		使用串口的目的就是为了节省AT89C55的引脚，用以实现其他的功能。

##### 1.2.2 矩阵键盘“片选”复用

![](C:\Users\15300\Desktop\数电实验\电子线路设计\key.JPG)

​		在<b><font face="微软雅黑">串口收发（上一小节）</font></b>中可以看到我们使用了两个<b><font face="微软雅黑">74HC573</font></b>（锁存器），使用锁存器为了进行键盘的复用。对锁存器的使能端进行片选操作，可以使用一个拨位开关选择。当某个锁存器接收到高电平时，响应锁存器进入高阻态，对应的单片机也就失去了对键盘的控制。

​		键盘的实现：使用AT89C55的P0口引出8根线进行扫描，有由上图所示，每一列将受到P0口的一个引脚控制，进行键盘扫描。键盘大小为5*8。而行输出介入到P2的低五位。<b><font face="微软雅黑">主机与从机的P0口引出的键盘控制线是相连的</font></b>，于是产生了一个问题：`当前是哪个单片机正在进行控制键盘扫描？`<b><font face="微软雅黑">我使用了单片机的P3.4口进行控制</font></b>，当锁存器片选低使能时，对应的T0输入高电平，表示此时可以让本单片机输出扫描信号。<b><font face="微软雅黑">对应地，另一个单片机将不输出键盘扫描信号以避免电平冲突</font></b>

<span id='lm044l'>

##### 1.2.3 LM044L显示器模块

​		经典20*4 的显示屏，属于较大，较为难以编写单片机控制程序的显示屏。其上接入另一个可以调节对比度（仿真的时候无效，现实可能有效）的滑动变阻器以及上拉电阻，其余的内容实际上和硬件实现没有关系了，主要是软件实现。

</span>

##### 1.2.4 蜂鸣器与数码管电路

​		蜂鸣器电路：<b><font face="微软雅黑">连接在主机的P3.4口进行输出</font></b>，限流电阻为500Ω，使用NPN进行信号放大，输出到(SOUNDER)上进行输出。主要功能就是各类**提示/警示**音。

​		数码管电路：由于存在4个完整引脚的单片机只有从机了，我们要实现一个BCD码数码管的输出，最方便的接入点就是<b><font face="微软雅黑">从机P1端口（全部未使用）</font></b>。按照低位接低位的顺序，可以正常输出。

##### 1.2.5 其他电路

<img src="C:\Users\15300\Desktop\数电实验\电子线路设计\others.JPG" style="zoom:80%;" />

​		存在一个拨位开关（单刀双掷），用于选择主机从机当前<b><font face="微软雅黑">哪一个单片机对键盘进行控制</font></b>，旁边接入了一个LED，用于指示：当从机进行工作，控制键盘时，提示操作者当前是从机控制（LED亮起）

---

#### 三、软件模块

由于我们使用了两个单片机，为了方便，我直接开了两个Keil C51工程进行编辑，所以存在两份工程说明

##### 1.3.1（从/主机）消息发送/接收模块(serial_talk)(serial_listen)

​		本模块对应了`serial_talk.c/serial_talk.h`以及`serial_listen.c / serial_listen.h`

​		serial_talk / serial_listen模块主要实现了串口消息的发送以及接收，其中主要设计到如下内容:

| 单片机寄存器（或特殊位） | 作用                                       |
| ------------------------ | ------------------------------------------ |
| SBUF                     | 串口消息发送接收时需要通过此寄存器进行存取 |
| EX0/EA                   | 外部中断以及总中断                         |
| TR0/TH/TL                | 定时器模块，与波特率的设置直接相关         |
| REN PCON SCON            | 串口通信的相关寄存器                       |

​		使用定时器实现波特率设定后（此处就不讲原理了，就是一个简单的时钟周期计算问题），进行收发。收发都存在需要注意的地方，就是RI / TI的等待：<b><font face="微软雅黑">很可能出现收发事件不一致的情况，或是接收需要话费很多个指令周期，需要使用自旋锁等待</font></b>。



##### 1.3.2 （从机）键盘事件模块(keyboard_module)

​		本模块对应了`keyboard_module.h / keyboard_module.c`

​		功能相对比较单一，主要实现了键盘的扫描输出（1. 扫描输出 2.按键延迟度过不稳定区 3. 长摁情况的忽略）。并且定义了一系列键盘事件 / 键盘映射到ASCII码，主要与显示模块(display_module)进行配合。

##### 1.3.3（主机）显示模块(display_module) （多功能）

​		本模块对应了`display_module.h / display_module.c`

​		模块实现的主要函数：

```c
void Init();				// 初始化

/// ================== 七个按键函数 =====================
void doPop();				// 行尾删除
void allClear();			// 清空(本行)
void confirm();				// 消息发送(或者密码输入)

/// @brief 键盘输入，光标跟随移动，正确的跨行光标显示
void writeCursor(uchar _data);

/// @brief 基本写入功能，data_flag = 0 写入指令，否则写入内容
void write(uchar _dat, bit data_flag);

/// @brief 写入一整列
/// @param align 对齐方式：左边（LEFT），居中（CENTRAL），右边（RIGHT）
void writeLine(uchar* ptr, uint line, bit clear, uchar align);

/// @brief 设置光标位置
void setCursor(uchar row, uchar col);
uchar checkBusy();			// 查询当前显示屏是否处于忙状态

void drawSuspend();			// 绘制密码输入界面
void drawIncomingMessage(uchar *buf, bit self);	// 绘制从 从机而来的消息（更新显示屏）
void printPassword(uchar pin);	// 密码输入替换为‘*’
void isPasswordRight();			// 判定密码输入是否正确，并播放对应的蜂鸣器音乐
void halfBeat(uchar t);			// 蜂鸣器模块输出一个半拍的定时时间
void melody(uchar time);		// 输出蜂鸣器事件
void playSound(uchar* song);	// 播放一整段音乐
```

​		可以看出模块的复杂性，并且考虑到编写者的使用方便，光是“显示在LCD屏上”就存在很多输出方式（比如如何对齐，是否清除其他内容）。使用类似于`writeLine`这样的函数可以非常方便地进行输出格式的调整。

​		软件模块划分较为有条理。使用Javadoc注释风格（比如@brief这种用法）。

##### 1.3.4 其他模块

​		本模块指：`utils.h`以及`utils.c`对应的代码，主要包括如下内容:

- ROM保存的不可变字符串内容

- ROM保存的音阶码

- delay函数以及字长统计函数

- 多个模块共同使用的标识位定义

  本模块头文件将被所有模块引用。

---

## II. 设计二 多功能计算器

---

#### 一、组合功能介绍

##### 2.1.0 框架与流程图

![](C:\Users\15300\Desktop\数电实验\电子线路设计\calc.png)

<center>多功能计算器鱼骨框架图</center>

![](C:\Users\15300\Desktop\数电实验\电子线路设计\flow.png)

<center>使用流程图</center>

##### 2.1.1 自动挂起以及开机挂起

​		仿真开始时，不会直接进入计算机主功能，进入挂起省电模式。此模式下，在进行显示输出之后，单片机进入循环监听键盘事件的状态。监听到“AC”键被按下将会自动退出挂起，进入计算模式。

​												<img src="C:\Users\15300\Desktop\数电实验\电子线路设计\sus.JPG" style="zoom: 50%;" />

​		设置挂起模式的目的是：1. 可以使开机过程存在一个缓冲。当我们不能简单地把仿真开始当成开机时，可以认为从挂起模式唤醒的过程就是一个模拟开机的过程。2. 在计算器长时间不用，使用者忘记关机时，可以使用自动挂起功能。<b><font face="微软雅黑">挂起模式其实可以优化，出于时间与精力上的考虑没有进行，思路如下：</font></b>使单片机进入**掉电模式**，此模式下CPU/定时器/串口全不工作，可以最大程度地减小功耗。在掉电模式下唯一可以唤醒的方式就是外部中断。这种实现也符合我们的按键唤醒模式。

##### 2.1.2 支持+/-/${\times}$/${\div}$ 以及括号运算的计算

​		计算机的主要模式。我觉得如果计算器只能像普通数码管计算器那样，只能单行输入，并且不存在括号对优先顺序的更改，不支持长表达式输出的话，<font size=5> 必然非常<b>low</b></font>。所以==**本计算器支持**==：

- <u>多行输入，使用数据缓冲区保存</u>

- <u>在确定计算之前可以行尾删除，行内修改</u>（PREV/NEXT移动光标到指定位置修改）

- <u>括号运算，长表达式输入，输出表达式最终结果</u>

  计算器主要功能其实并不复杂，但在其实现并不复杂，<b><font face="微软雅黑">参见以下PDF内部跳转链接：</font></b>

  - [**2.3.3 栈模块（计算功能）（stack_module）**](#stackmodule)
  - [<u>**III. 实现过程中遇到的主要问题**</u>](#majorproblem)

##### 2.1.3 菜单/设置界面

​		

| <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\set.JPG" style="zoom:50%;" /> | <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\menu.JPG" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                           设置界面                           |                           菜单界面                           |

​		设置界面和菜单界面的操控：

- 使用PREV/NEXT按键进行循环切换选项
- 使用“=”按钮进行【模式选择】（菜单）或者【切换ON/OFF设置】（设置）

​		两个界面在键盘上存在单独的按键进行选择切换。点击后会出现对应界面。光标所指的选项为当前正要设置或是正要进入的选项（显然）。存在多个可选模式/设置

| 模式名称        | 作用                                | 设置名称    | 作用                 |
| --------------- | ----------------------------------- | ----------- | -------------------- |
| (Calculation)   | 计算模式，计算器的主要模式          | 45s Suspend | 45s自动挂起开关      |
| (Sensor)        | 传感器模式，可以读取DS18B20温度读数 | Press Sound | 键盘按下是否有提示音 |
| (Alarm Setting) | 闹钟设置                            | LED Light   | 键盘按下是否有指示灯 |

##### 2.1.4 温度显示

| <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\hot.JPG" style="zoom:50%;" /> | <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\cold.JPG" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|           摄氏度显示：31℃ 描述（Damn Hot）（贼热）           |           华氏度显示：37℉ 描述（Freezing）（冻死）           |

​		显示从DS18B20读取来的温度数据，但注意，不是实时更新的。假如此时我们在DS18B20端改变了输出温度的数值，显示屏不会更新（限制刷新率），需要按下按键，通过键盘事件推动显示更新。

​		使用【PREV/NEXT】按键可以切换摄氏度/华氏度显示，在第三行同时存在对本段温度的描述。

##### 2.1.5 闹钟设置

| <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\no.JPG" style="zoom:50%;" /> | <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\alarm.JPG" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                  闹钟没有设置的计算界面显示                  |               闹钟设置界面（当前正在设置[分]）               |
| <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\yes.JPG" style="zoom:50%;" /> | <img src="C:\Users\15300\Desktop\数电实验\电子线路设计\on.JPG" style="zoom:50%;" /> |
|                   闹钟设置后的计算界面显示                   |          闹钟响了（播放我最喜欢的歌曲 So Far Away）          |

​		闹钟通过键盘进行设置，可以切换【分钟/秒钟】的时间（以更加快速地设置更长的闹钟时间）。而由于显示屏横向长度的限制，加入小时数设计将不太合适（太长了，在一行内不能显示完闹钟设置项，产生不连贯性），故闹钟最大时常为59min59s。

​		而闹钟是否设置，会在计算模式的顶部栏进行显示（如左边两个图显示的结果）。闹钟时间到后，将会播放闹钟音乐并且自动将顶部状态栏设置回到原来【No Alarm】的情况。

​		本功能还遗留一个没有解决的问题，见[**<u>III. 实现过程中遇到的主要问题</u>**](#majorproblem)

---

#### 二、硬件实现

##### 2.2.1 AT89C55

​		本实验在开始时就选择使用AT系列中，内存最大的一块单片机AT89C55（事实证明还是不太够用，见[**<u>III. 实现过程中遇到的主要问题</u>**](#majorproblem)）。

​		使用本单片机进行实现的好处主要有：

- 电路引脚简单，寄存器的使用相对易于学习

- 内存空间大，适合做规模较大的单片机开发。

  本实验AT89C55个输出端口的连线情况如下：

  <table>
      <tr>
          <td><b>实际电路</b></td>
          <td><b>引脚及其功能</b></td>
      </tr>
      <tr>
          <td rowspan="4"><img src="C:\Users\15300\Desktop\数电实验\电子线路设计\at.JPG" style="zoom:50%;" /></td>
          <td>P0:外接上拉，连接LCD显示屏</td>
      </tr>
      <tr>
          <td>P1:键盘扫描接收端</td>
      </tr>
      <tr>
          <td>P2：部分连接LCD控制线，部分为键盘扫描</td>
      </tr>
      <tr>
          <td>P3：部分为键盘扫描，P3.7为DS18B20传感器读写端</td>
      </tr>
  </table>

##### 2.2.2 LM044L显示器模块

​		本显示模块的实现与设计一中几乎一致，见[**1.2.3 LM044L显示器模块**](#lm044l)。(我的设计初衷就是，好的模块可以方便复用以及迁移，显示软件模块仍然是设计的重点)

##### 2.2.3 矩阵键盘与LED（键盘灯）模块

​		矩阵键盘的硬件实现如下图所示：![](C:\Users\15300\Desktop\数电实验\电子线路设计\keys.JPG)

​		实现的方式基本一致：此为4 * 6大小的扫描矩阵键盘。大多数键都是不可复用的（没有复用的需求）。可以看出，除了核心的计算按键之外，剩余的按键全是功能性按键，可能被复用。每列上方存在非门与LED灯，在没有按键按下的情况下，没有LED灯被点亮。点亮的条件为：<b><font face="微软雅黑">1. 设置（Settings）中，键盘灯选项被打开（对应单片机接口变为低电平，否则二极管不导通） 2. 对应列有键被按下</font></b>

##### 2.2.4 DS18B20温度传感器、蜂鸣器

​		各个小型元件的位置与引脚连接情况如下图所示：

​			<img src="C:\Users\15300\Desktop\数电实验\电子线路设计\ds.JPG" style="zoom: 80%;" />

​		其中DS18B20除了VCC GND之外，只有一根通信线与单片机相连。电路十分简单，代价是**时序 / 读数转化 十分复杂**。其中[3.0]为当前设定温度的显示，其下两个红色按钮为温度设置调节按钮。

​		蜂鸣器的接法与设计一中类似，P2.3口输出方波信号，由限流 / NPN放大后输出到SOUNDER。

---

#### 三、软件模块

##### 2.3.1 显示模块（display_module）

​		本模块设计的内容非常多，代码说明如下：

```c
extern uchar now_row;		// 当前光标行
extern uchar now_col;		// 当前光标列
extern uchar head_row;		// 当前屏幕上字符最大达到的行
extern uchar head_col;		// 当前屏幕上字符最大达到的列

extern uchar buffer[24];	// 输入缓冲区
extern uint _temp;			// 温度记录
extern bit use_cel;			// 使用摄氏度显示
extern bit tobe_reset;		// 在等号按下后，重新输入需要清零

void Init();				// 初始化

/// ================== 七个按键函数 =====================
void doPop();				// 行尾删除
void allClear();			// 清空
void settings();			// 设置
void mainMenu();			// 主菜单
void yieldResult();			// 等号操作
void moveLeft();			// 光标左移
void moveRight();			// 光标右移

void writeCursor(uchar _data);	// 光标边界检测 + 输入
void write(uchar _dat, bit data_flag);		// 简单写入
void writeLine(uchar* ptr, uint line, bit clear, uchar align);		// 写入列
void setCursor(uchar row, uchar col);
uchar checkBusy();

/////////////////////////////////////////////////////////////////////////////////
// =============== 可以发现以上函数（到）第15行与设计一的显示模块一致 ================ //
/////////////////////////////充分体现了模块的易迁移性////////////////////////////////

void drawSettings();			// 绘制设置界面
void drawMainMenu();			// 绘制菜单界面
void drawError(uchar err);		// 绘制三种错误（由于用户输入/计算产生的错误）
void drawTemperature(bit skip);	// 绘制温度显示界面
void drawAlarmUI(bit skip);		// 绘制闹钟设置界面
void alarmingEffect();			// 绘制闹钟进行时的界面
void drawSuspend();				// 绘制挂起界面
```

​		`display_module.h`中还包含很多宏定义，目的是方便快速使用LM044L的显示屏特性：

| 宏名称            | 作用                    | 宏名称               | 作用              | 宏名称              | 作用              |
| ----------------- | ----------------------- | -------------------- | ----------------- | ------------------- | ----------------- |
| INITIAL           | 0x38 LM044L<br>初始设置 | CURSOR_<br>BLINK     | 0x0f 光标闪烁     | CURSOR_<br>BACKWARD | 0x04  光标后移    |
| CLA               | 0x01 屏幕全清           | CURSOR_<br>NON_BLINK | 0x0e 光标不可闪烁 | DISPLAY<br>_LEFT    | 0x07 整体左移一格 |
| DISPLAY<br>_START | 0x80 开始显示的指针位置 | NO_CURSOR            | 0x0c 不显示光标   | DISPLAY<br>_RIGHT   | 0x05 整体右移一格 |
| SHOW_<br>CURSOR   | 0x0d 显示光标           | CURSOR_<br>FORWARD   | 0x06 光标向后移动 | CURSOR<br>_LEFT     | 0x10 光标左移一格 |
| CURSOR<br>_RIGHT  | 0x14 光标右移一格       |                      |                   |                     |                   |

​		显示模块集成的功能最多，几乎在此引用所有其他模块，其需要沟通计算模式 / 传感器显示 / 闹钟设置 / 设置环节 / 挂起显示 等等重要功能的显示。

##### 2.3.2 键盘响应模块（keyboard_module）

​		此模块的功能较为单一，功能如下表叙述：

| 键盘事件    | 函数          | 响应方式                                                    |
| ----------- | ------------- | ----------------------------------------------------------- |
| 按下字符键  | 某字符        | 将对应字符的ASCII码输入到缓冲区，调用显示函数显示此输入字符 |
| 按下DEL键   | doPop()       | 缓冲区删除一个字符，光标左移并清除对应已经绘制区域          |
| 按下AC键    | allClear()    | 显示全部清除，缓冲区全部清除，标识位全设置成与计算模式相关  |
| 按下Setting | settings()    | 调整模式为设置模式，调用设置界面绘制函数                    |
| 按下Menu    | mainMenu()    | 调整模式为菜单模式，调用菜单界面绘制函数                    |
| 按下“=”号   | yieldResult() | 输出计算结果 / 更改设置 / 进入某模式 / 确认设置             |
| 按下PREV    | moveLeft()    | 光标左移 / 更改选中的选项 / 调整摄氏度华氏度输出            |
| 按下NEXT    | moveRight()   | 光标右移 / 更改选中的选项 / 调整摄氏度华氏度输出            |

##### 2.3.3 栈模块（计算功能）（stack_module）

<span id="stackmodule">

​		这个模块的编写最为复杂，并且实现过程中也遇到[一些问题](#majorproblem)。

​		首先我们设置了两个<b><font face="微软雅黑">struct，两个struct为同一个结构体“Stack”的两个实例。</font></b>Stack结构体，顾名思义就是：“栈”。我们对于计算功能的实现，必须依赖于栈（才能正确分解表达式，重组计算值）。由于我们不需要使用可变结构（C51有可变结构吗？malloc好像不存在），只需要内部写死：栈的空间为12个uchar （unsigned char），存在一个栈顶标识，标志当前栈顶的位置，方便push pop操作。<b><font face="微软雅黑">其中一个为操作符栈（oprt），另一个为操作数栈（oprd）。</font></b>算法可以依靠栈来执行，在放上流程图之前必须说明，由于某种原因（在[III.实现中的问题](#majorproblem)中会提到），我们不能使用浮点运算，但我写的第一版代码是支持浮点运算的，现在只支持uchar的加减乘除，故流程图依然使用浮点运算的算法：

![](C:\Users\15300\Desktop\数电实验\电子线路设计\stack.png)

​		通过以上算法可以计算出当前的字符。（事实上这个算法原理非常简单，我们在数据结构与算法实验里都写过，详情咨询刘源老师）

</span>

##### 2.3.4 传感器模块（sensor_module）

​		主要是时序的难题：

1、过程1、2是初始化过程，每次读取都要初始化，否则18b20处于待机状态，无法成功读取。过程1：拉低信号线480-700us，使它复位，然后释放总线15-60us，18b20会拉低总线60-240us，然后它释放总线。所以初始化成功的一个标志就是能否读到18b20这个先低后高的操作时序。

　　(注意：黑色部分表示主机操作，蓝色部分表示18b20操作，每次主机操作完成之后等待18b20状态时，必须要释放总线，比如将IO设置为高阻态什么的。否则18B20没法把状态写到线上)

　　2、过程3、4是写1bit数据过程。过程3是写0 ，过程4是写1。过程3：拉低总线60us，然后抬高总线5us，完成。过程4：拉低总线5us，然后抬高总线60us，完成

　　3、过程5、6是读1bit过程。过程5是读0，过程6是读1。过程5、6：拉低总线5us，然后释放总线，读取总线，如果为0，则读入0，如果为1，则读入1。

　　DS18B20时序

　　初始化序列——复位和存在脉冲

> ​		1. 过程1、2是初始化过程，每次读取都要初始化，否则18b20处于待机状态，无法成功读取。过程1：拉低信号线480-700us，使它复位，然后释放总线15-60us，18b20会拉低总线60-240us，然后它释放总线。所以初始化成功的一个标志就是能否读到18b20这个先低后高的操作时序。
>
> 　　(注意：黑色部分表示主机操作，蓝色部分表示18b20操作，每次主机操作完成之后等待18b20状态时，必须要释放总线，比如将IO设置为高阻态什么的。否则18B20没法把状态写到线上)
>
> 　　2. 过程3、4是写1bit数据过程。过程3是写0 ，过程4是写1。过程3：拉低总线60us，然后抬高总线5us，完成。过程4：拉低总线5us，然后抬高总线60us，完成
>
> 　　3. 过程5、6是读1bit过程。过程5是读0，过程6是读1。过程5、6：拉低总线5us，然后释放总线，读取总线，如果为0，则读入0，如果为1，则读入1。　　
>
> ​		DS18B20的所有通信都由由复位脉冲组成的初始化序列开始。该初始化序列由主机发出，后跟由DS18B20发出的存在脉冲(presence pulse)。当发出应答复位脉冲的存在脉冲后，DS18B20通知主机它在总线上并且准备好操作了。
>
> 　　在初始化步骤中，总线上的主机通过拉低单总线至少480μs来产生复位脉冲。然后总线主机释放总线并进入接收模式。
>
> 　　当总线释放后，5kΩ的上拉电阻把单总线上的电平拉回高电平。当DS18B20检测到上升沿后等待15到60us，然后以拉低总线60-240us的方式发出存在脉冲。
>
> 　　如文档所述，主机将总线拉低最短480us，之后释放总线。由于5kΩ上拉电阻的作用，总线恢复到高电平。DS18B20检测到上升沿后等待15到60us，发出存在脉冲：拉低总线60-240us。至此，初始化和存在时序完毕。

​		程序按照如上叙述进行实现，最终我们选择了精度最低的传感器温度转化模式（0.5℃），此模式下转化时间只需要100ms，在按下按键之后不需要等待1s的时间（最高精度0.0625℃时的转化时间，12位精度）。

##### 2.3.5 附加模块（append_module）

​		其中主要存在四个部分：

- 闹钟模块
- 定时挂起模块
- 蜂鸣器音乐播放模块
- 其他常用函数 / 定义 / ROM字串定义

​		闹钟模块与定时挂起模块均与定时器存在关联，均实现了响应的定时器中断。其中闹钟与自动挂起使用的为同一个定时器寄存器T0，优先级关系如下：当不存在闹钟，但设置了45s自动挂起时，定时器完全由45s自动挂起程序管理，当存在键盘事件时，重置定时累加（因为我这是无操作45s自动挂起）。反之，如果存在闹钟设置，首先将由闹钟程序管理T0定时器，也即闹钟存在时，无论自动挂起是否设置，都将被屏蔽。**只有闹钟执行结束后，自动挂起才能管理T0定时器**。

​		蜂鸣器使用T1定时器，进行歌曲输出。歌曲音调有点奇怪，我很喜欢的一首歌就这样被毁了（笑）。

---

### III. 实现过程中遇到的主要问题

<span id="majorproblem">

I. 程序过大

​		刚开始实现时，本来以为使用AT89C55（说是RAM很大）可以不用考虑程序大小的问题，结果第三次实验课上直接debug搞坏了心态。最后查到的原因，引用如下：

> *** ERROR L107: ADDRESS SPACE OVERFLOW
>
> ​    SPACE:   DATA    
>
> ​    SEGMENT: _DATA_GROUP_
>
> ​    LENGTH:  0020H
>
> 
>
> Program Size: data=168.7 xdata=0 code=6039

​		我实现了一个栈长20的（浮点数栈）浮点计算功能，但是一个浮点数所占内存太大了（一个顶4个uchar），直接导致data区溢出。之后我尝试使用以下方法解决：

![](C:\Users\15300\Desktop\数电实验\电子线路设计\solve.JPG)

​		调整编译模式以及内存模型。默认使用的是【Small: Variables in DATA】也就是所有的代码（除了ROM内容之外）全部存在DATA中。而DATA只有6KB，显然不行。于是我尝试使用【Compact】或者【Large】模式进行编译，让代码可以保存在别的内存区，得到更大的空间（64KB）（很兴奋）。但是不行！使用PDATA/XDATA保存代码编译结果的后果就是：拿代码紧凑性 / 空间换执行效率，会导致显示屏模块一直崩溃（就是编译模式的问题，和代码实现没有关系，做了很多次实验）。没有办法，只能砍掉部分功能（比如浮点计算，全两行输入（现在只能输入1.5行））

II. 蜂鸣器

​		蜂鸣器在设计二中出现了音调不连续的问题，初步诊断音调过高。将音调改低后发现确实可以通过降8度的方式得到更好的输出结果，但是还是没有完全解决。个人尝试了如下方法：1. 继续降音调 2. 修改限流电阻 3. 改变放大电路结构。都失败了。。。

​		不过在进行设计一电路实验时（我先做的设计二），使用蜂鸣器输出消息提示音等声音，发现完全不存在问题。对比代码发现，两代码使用的定时器不同，一个是T0，一个是T1。而设计一中已经使用了T0，被迫只能使用T1，造成了这样的结果（也可能是定时器工作状态没设置好）。

</span>

---

### IV. 参考文献

【1】（主要是这一本书（很厚））新概念51单片机C语言教程，郭天祥，电子工业出版社 [链接](https://baike.baidu.com/item/新概念51单片机C语言教程/7355981?fr=aladdin)

【2】网页链接：[Proteus 串口仿真](http://blog.sina.com.cn/s/blog_574d08530100hka4.html)

【3】网页链接：[C51 串口通信](https://blog.csdn.net/qq_43743762/article/details/89390128)

【4】 数据结构（C语言版），严蔚敏，清华大学出版社

---

### V. 附录（体量巨大）

---

​		本人已经将代码（包括工程项目 / 代码项目）<b><font face = "微软雅黑" size = 5>开源到Github上</font></b>，可以点击 （网页链接）[【MyC51代码库】](https://github.com/Enigmatisms/MyC51)，其中包含了所有代码（包括多项练习程序），在Github Commit信息中可以看到本人每次的修改情况。在对应的README.md（使用说明）中也写了本人的实现过程。代码完全由本人原创。

​		开源遵循MIT License（[什么是MIT License？](https://github.com/Enigmatisms/MyC51/blob/master/LICENSE)）中的规则。有需要请联系 <u>1530097266@qq.com</u>

​		设计一对应库中的 `wechat` 文件夹下的所有内容

​		设计二对应库中的 `calculator` 文件夹下的所有内容

​		其余内容均是练手项目

​		提示：<b><font face = "微软雅黑" size = 4 color='blue'>接下来代码很多，建议使用目录进行浏览。两个项目代码量加起来应该2000~3000行吧</font></b>

​		一键跳转回到顶部：点击此PDF链接[点我](#tophead)

#### 5.1 设计一  模拟微信

##### 5.1.1 原理图

![](C:\Users\15300\Desktop\数电实验\电子线路设计\d1.JPG)

##### 5.1.2 代码

```C
/**
 * ================= 键盘模块 ====================
 * @brief LCD 4 * 6 矩阵键盘模块
 * @date 2020.10.5
 * @author 何千越
*/

#ifndef __KEYBOARD_MODULE_H__
#define __KEYBOARD_MODULE_H__
#include <reg52.h>
#include <intrins.h>
#include "serial_listen.h"
#include "display_module.h"

extern bit cap;
extern uchar code charTable[40];
extern uchar code digit2Sign[6];

uint sweepingScan();
void keyboardEvent(uint pos);

#endif 	//__KEYBOARD_MODULE_H__
```

```C
#include "keyboard_module.h"

bit cap = 0;

uchar code charTable[40] = {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
	'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
	'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
	'w', 'x', 'y', 'z',   0, ' ',   1,   2,
};

uchar code digit2Sign[6] = {
	',', '.', '?', '!', '&', '\''
};

uint sweepingScan(){
	uchar i, res, out = 0xfe;
	for (i = 0; i < 5; i++){
		P0 = out;					// 扫描
		out = _crol_(out, 1);		// 低电平左移一位
		res = P2;
		if (res != 0xfc){
			switch (res){
				case 0xfe: return 8 * i;
				case 0xfd: return 8 * i + 1;
				case 0xfb: return 8 * i + 2;
				case 0xf7: return 8 * i + 3;
				case 0xef: return 8 * i + 4;
				case 0xdf: return 8 * i + 5;
				case 0xbf: return 8 * i + 6;
				case 0x7f: return 8 * i + 7;
			}
		}
		delayMs(1);
	}
	P0 = 0x1f;
	return 40;			// 没有键盘事件
}

void keyboardEvent(uint pos){
	uchar ch;
	ch = charTable[pos];
	if (ch >= 32){
		if (cap == 1){
			if (ch < '6'){
				ch = digit2Sign[ch - '0'];
			}
			else if (ch >= 'a'){
				ch -= 32;				// 得到大写字母
			}
		}
		if (_mode == CHATTING){
			writeCursor(ch);
		}
		else if (_mode == LOCKED){
			printPassword(ch);
		}
	}
	else{
		if (_mode <= LOCKED){
			switch(ch){
				case 0: cap =~ cap; break;
				case 1: 
					doPop();
				break;
				case 2: 
					if (_mode == CHATTING){
						drawIncomingMessage(buffer, 1);		// 本机键盘响应输入绘制
					}
					else {
						isPasswordRight();
					}
				break;
			}
		}
	}
}
```

```C
#include "serial_listen.h"
#include "display_module.h"
#include "keyboard_module.h"

void main(){
	uint pos, old_pos = 40;
	Init();
	subscriberInit();
	_mode = LOCKED;
	drawSuspend();
	setCursor(2, 5);
	while (1){
		if (ready == 1){			// 接收串口消息时不响应键盘
			receive();
		}
		else{						// 带延迟10ms的键盘
			if (T0 == 0){
				pos = sweepingScan();
				if (pos != 40 && pos == old_pos){
					continue;
				}
				if (pos < 40){
					keyboardEvent(pos);
				}
				delayMs(10);
				old_pos = pos;
			}
		}
		if (draw_allow == 1){		// 输出则进行输出
			drawIncomingMessage(receiveBuffer, 0);	// 来自对方的输入
			playSound(message_tone);
		}
	}
}
```

```C
/**
 *	========== 串口通信，只管接收数据的模块 ============
 *
 * 
*/
#ifndef __SERIAL_LISTEN_H__
#define __SERIAL_LISTEN_H__
#include "utils.h"

extern uchar receiveBuffer[20];
extern uchar buffer_ptr;
extern bit ready;
extern bit draw_allow;

void subscriberInit();
void receive();
void bufferReset();

#endif 	//__SERIAL_LISTEN_H__
```

```C
#include "serial_listen.h"

uchar receiveBuffer[20];
uchar buffer_ptr = 0;
bit ready = 0;
bit draw_allow = 0;

void subscriberInit(){
	TMOD = 0x20;                     //设置定时器T1工作于方式2
	SCON = 0x50;                     //串口工作方式1，允许接收数据
	PCON = 0x00;                     //波特率不倍增
	TH1 = 0xf4;                      //波特率为2400b/s
	TL1 = 0xf4;
	TR1 = 1;                         //启动定时器T1
	REN = 1;                         //允许接收数据
	EX0 = 1;						 // 打开外部中断0，作为接收结束标志
	EA = 1;
	IT0 = 1;						 // 下降沿触发
	T0 = 0;
}

void receive() {        	
	uchar i, j, temp;
	for (i = 0; i < 250; i++){		// TIMEOUT时间 250ms
		for (j = 0; j < 110; j++){
			if (RI != 0){
				break;
			}
		}
		if (j < 110){
			break;
		}
	}
	RI = 0;                           				// 接收完毕时清零
	if (buffer_ptr < 20){
		temp = SBUF;         // 将接收缓冲器中的数据存入dat
		if (temp == '#'){
			ready = 0;
			draw_allow = 1;
			return;
		}
		else {
			receiveBuffer[buffer_ptr] = temp;
			buffer_ptr++;
		}
	}
	else {
		ready = 0;
		draw_allow = 1;
	}
}

void bufferReset(){
	for (buffer_ptr = 0; buffer_ptr < 20; buffer_ptr++){
		receiveBuffer[buffer_ptr] = '\0';
	}
	buffer_ptr = 0;
}

// 接到数据提醒，开始收数据
void receiveStart() interrupt 0
{
	ready = 1;
}
```

```C
/**
 * ================= LCD显示模块 ====================
 * @brief LCD 20x4 函数定义以及相关宏
 * @date 2020.10.4
 * @author 何千越
*/

#ifndef __DISPLAY_MODULE_H__
#define __DISPLAY_MODULE_H__

#include <reg52.h>
#include "utils.h"
#include "serial_listen.h"

#define DELAY 1

// ================ LCD宏 ===================//
#define INITIAL 			0x38
#define CLA 				0x01
#define DISPLAY_START 		0x80

#define CURSOR_BLINK 		0x0f
#define CURSOR_NON_BLINK 	0x0e
#define SHOW_CURSOR 		0x0d
#define NO_CURSOR 			0x0c
#define CURSOR_FORWARD 		0x06
#define CURSOR_BACKWARD 	0x04
#define DISPLAY_LEFT 		0x07
#define DISPLAY_RIGHT 		0x05
#define CURSOR_LEFT 		0x10
#define CURSOR_RIGHT 		0x14
#define ALL_LEFT 			0x18
#define ALL_RIGHT 			0x1c


sbit RS = P3 ^ 5;
sbit RW = P3 ^ 6;
sbit EN = P3 ^ 7;
sbit SPEAKER = P3 ^ 3;

extern bit self_old;				// 历史消息是本机而非来自串口
extern bit has_history;			// 是否存在历史消息
extern uchar head_col;		// 当前屏幕上字符最大达到的列
extern uchar toneHigh, toneLow;

extern uchar buffer[20];	// 输入缓冲区
extern uchar oldBuffer[20];	// 历史消息缓冲区

void Init();				// 初始化

/// ================== 七个按键函数 =====================
void doPop();				// 行尾删除
void allClear();			// 清空(本行)
void confirm();				// 消息发送(或者密码输入)

void writeCursor(uchar _data);	// 光标边界检测 + 输入
void write(uchar _dat, bit data_flag);		// 简单写入
void writeLine(uchar* ptr, uint line, bit clear, uchar align);		// 写入列
void setCursor(uchar row, uchar col);
uchar checkBusy();

void drawSuspend();
void drawIncomingMessage(uchar *buf, bit self);
void printPassword(uchar pin);
void isPasswordRight();
void halfBeat(uchar t);
void melody(uchar time);
void playSound(uchar* song);
#endif 	//__DISPLAY_MODULE_H__
```

```C
#include "display_module.h"

uchar buffer[20];
uchar oldBuffer[20];
bit self_old = 1;	
bit has_history = 0;
uchar head_col = 0;
uchar toneHigh = 1, toneLow = 1;

void Init(){
	write(INITIAL, 0);
	write(CLA, 0);
	write(SHOW_CURSOR, 0);
	write(CURSOR_FORWARD, 0);
	write(CURSOR_BLINK, 0);
	allClear();
}

uchar busyCheck()   //忙检查
{
  uchar	status;
  RS = 0;	 
  RW = 1;	 
  EN = 1;	 
  delayMs(DELAY);
  status = P1; 	//读出P1最高位状态值
  EN = 0;
  return status;
}

/// 写入数据或者指令
void write(uchar _data, bit data_flag){
	while((busyCheck()&0x80) == 0x80);
	RW = 0;
	RS = data_flag;		// data_flag为1时为写入数据
	EN = 0;
	delayMs(DELAY);
	EN = 1;
	P1 = _data;
	delayMs(DELAY);
	EN = 0;				// 约2 * DELAY ms的脉冲
}

// 在行尾补充
void writeCursor(uchar _data){							// 光标未对齐时只更改当前位置上的字符，不会影响最大长
	if (head_col < 19){
		write(_data, 1);
		buffer[head_col] = _data;
		head_col ++;
	}
}

void writeLine(uchar* ptr, uint line, bit clear, uchar align){
	uint index;
	uchar start_pos = 0;
	switch(align){
		case CENTRAL:
			start_pos = (uchar)((20 - strlen(ptr)) / 2); break;
		case LEFT:
			break;
		case RIGHT:
			start_pos = (uchar)(20 - strlen(ptr)); break;
		default:
			break;
	}
	if (clear == 0){
		write(DISPLAY_START + line_offset[line] + start_pos, 0);
		for (index = 0; index < 20 && ptr[index] >= 10; index++){
			write(ptr[index], 1);
		}
	}
	else{
		write(DISPLAY_START | line_offset[line], 0);
		for (index = 0; index < start_pos; index ++){
			write(0x20, 1);
		}
		for (index = 0; index < 20 && ptr[index] >= 0x0a; index ++){
			write(ptr[index], 1);
		}
		for (; index < 20 - start_pos; index ++){
			write(0x20, 1);
		}
	}
}

//========================光标移动（包括写入/删除）==========================

void setCursor(uchar row, uchar col){
	write(DISPLAY_START + line_offset[row] + col, 0);
}

/// 编号0 @brief删除行末字符
void doPop(){
	if (head_col > 0){
		head_col --;
		write(CURSOR_LEFT, 0);		// 光标移动到末尾字符上	
		write(' ', 1);				// 清除
		write(CURSOR_LEFT, 0);		// 由于光标一直采取右移的方式，写入以后会右移一位，则需要左移
		buffer[head_col] = 0;		// 删除
	}
}

/// 编号1 @brief AC @todo 此后需要增加：清除栈内所有内容
void allClear(){
	write(CLA, 0);
	writeLine(wechat_info[0], 0, 1, CENTRAL);
	write(SHOW_CURSOR, 0);
	setCursor(3, 0);
	_mode = CHATTING;
	for (head_col = 0; head_col < 20; head_col++){
		*(buffer + head_col) = 0;
	}
	head_col = 0;
}

void drawSuspend(){
	uchar i;
	for (i = 0; i < 3; i++){
		writeLine(lock_info[i], i, 1, CENTRAL);
	}
	writeLine(lock_info[0], 3, 1, CENTRAL);
	setCursor(2, 5);
}

void drawIncomingMessage(uchar* buf, bit self){
	uchar i;
	if (has_history == 1){
		if (self_old == 1){
			writeLine(oldBuffer, 1, 1, RIGHT);
		}
		else {
			writeLine(oldBuffer, 1, 1, LEFT);
		}
		if (self == 1){
			writeLine(buf, 2, 1, RIGHT);
		}
		else {
			writeLine(buf, 2, 1, LEFT);
		}
	}
	else{
		if (self == 1){
			writeLine(buf, 1, 1, RIGHT);
		}
		else {
			writeLine(buf, 1, 1, LEFT);
		}
		has_history = 1;
	}
	self_old = self;		// 历史消息是否来自本机键盘响应设置
	for (i = 0; i < 20; i++){
		oldBuffer[i] = buf[i];
		buf[i] = 0;
	}
	if (self == 0){			// 本次绘制来自对方的输出，那么为自动响应的，需要清除
		draw_allow = 0;
		bufferReset();		// 包含receiveBuffer的重置以及索引重置
	}
	else{
		writeLine(" ", 3, 1, LEFT);
		head_col = 0;		// 自身输入的索引为head_col
	}
	setCursor(3, 0);
}

void printPassword(uchar pin){
	if (head_col < 9){
		if (head_col > 0){
			write(CURSOR_LEFT, 0);
			write('*', 1);				// 将上一位设置为 *
		}
		writeCursor(pin);
	}
}

void isPasswordRight(){
	uchar i;
	for (i = 0; i < 9; i++){
		if (buffer[i] != password[i]){
			writeLine(wechat_info[1], 1, 1, LEFT);
			writeLine(lock_info[2], 2, 1, LEFT);
			break;
		}
	}
	if (i < 9){
		counter++;
		if (counter >= 3){
			_mode = FAULTS;			// 三次密码失败模式
			writeLine(wechat_info[2], 2, 1, CENTRAL);
			write(NO_CURSOR, 0);
			return;
		}
		for (i = 0; i < 9; i++){
			buffer[i] = 0;
		}
		head_col = 0;
		setCursor(2, 5);
		playSound(error_tone);
	}
	else {		// 通过
		writeLine(wechat_info[3], 1, 1, LEFT);
		playSound(unlock_tone);
		allClear();
	}
}

/// @brief 蜂鸣器方波输出
void rectWave() interrupt 1
{
	TR0 = 0;
	SPEAKER =! SPEAKER;
	TH0 = toneHigh;
	TL0 = toneLow;
	TR0 = 1;
}

void halfBeat(uchar t){
	uchar t1;
	uint t2;
	for(t1 = 0; t1 < t; t1++){
		for(t2 = 0; t2 < 16000; t2++){
			;
        }
	}
	TR0 = 0;
}

void melody(uchar time){
	TR0 = 1;
	halfBeat(time);                      
}

void playSound(uchar* song){
	uchar i, k, time;
	ET0 = 1;
	for (i = 0; i < 9; i += 3){
		k = song[i] + 7 * song[i + 1] - 1;
		toneHigh = FREQH[k];
		toneLow = FREQL[k];
		time = song[i + 2];
		melody(time);
	}
	ET0 = 0;
	TR0 = 0;
}

```

```C
/**
 * ================= 公用函数以及类型 ====================
 * @date 2020.10.4
 * @author 何千越
*/
#ifndef __UTILS_H__
#define __UTILS_H__

#include <reg52.h>
#define uint unsigned int
#define uchar unsigned char
	

#define CENTRAL 0
#define LEFT	1
#define RIGHT	2
#define CHATTING 	0		// 正常模式
#define LOCKED		1		// 锁起
#define FAULTS		2		// 错误（密码错误3次）

extern uchar _mode;			// 
extern uchar counter;		// 密码错误次数
	
// 行偏移
extern uchar code line_offset[4];

extern uchar code FREQH[28];

extern uchar code FREQL[28];

extern uchar code message_tone[9];
extern uchar code unlock_tone[9];
extern uchar code error_tone[9];

extern uchar code password[9];

extern uchar code lock_info[3][20];

extern uchar code wechat_info[4][20];

int strlen(uchar* ptr);

void delayMs(uint ms);

#endif 	//__UTILS_H__
```

```C
#include "utils.h"

uchar _mode = 0;					// 主要模式
uchar counter = 0;

uchar code line_offset[4] = {
	0x00, 0x40, 0x14, 0x54
};

uchar code wechat_info[4][20] = {
	"**WeChat C51 V 1.0**",
	"* Incorrect input! *",
	" 3 faults. Locked. ",
	"* Device unlocked! *"
};

uchar code lock_info[3][20] = {
	"********************",
	" Password Required: ",
	"*PIN:              *",
};

uchar code password[9] = "123456789";

uchar code FREQH[28] = {
    248, 247, 246, 245, 245, 243, 242,
    252, 252, 251, 251, 250, 250, 249, 249,
    254, 253, 253, 253, 253, 252,   
    255, 254, 254, 254, 254, 254, 254,
};

uchar code FREQL[28] = {
    182, 209, 208, 182, 23, 193, 66,
    143, 91, 233, 104, 216, 140, 225, 33,
    45, 244, 180, 107, 68, 238, 
    22, 250, 218, 182, 162, 119, 71,
};// 音阶频率表 低八位

uchar code message_tone[9] = {
	5, 0, 2, 4, 0, 2, 6, 0, 2,
};

uchar code unlock_tone[9] = {
	2, 0, 2, 7, 0, 2, 2, 0, 2
};

uchar code error_tone[9] = {
	2, 0, 2, 3, 0, 2, 4, 0, 2
};

int strlen(uchar* ptr){
	int i = 0;
	while(i < 20){
		if (ptr[i] < 0x0a){
			return i;
		}
		i++;
	}
	return 20;
}

void delayMs(uint ms){
	int i, j;
	for (i = ms; i > 0; i--){
		for (j = 110; j > 0; j--){
			;
		}
	}
}
```

```C
/// 消息发送
#ifndef __SERIAL_TALK_H__
#define __SERIAL_TALK_H__
#include "utils.h"
#include <intrins.h>

sbit FLAG = P3 ^ 2;

extern uchar sendBuffer[20];
extern uchar buf_ptr;
extern uchar code testString[4][20];
extern uchar test_ptr;
extern uchar counter;

void send();
void bufferInput(uchar dat);	// 缓冲输入
void bufferReset();				// 清空缓冲
void bufferPop();				// 删除一个值
void messageBuzz();				// 消息发送提示音
void publisherInit();

#endif 	//__SERIAL_TALK_H__
```

```C
#include "serial_talk.h"

uchar counter = 0;
uchar sendBuffer[20];
uchar buf_ptr;
uchar code testString[4][20] = {
	"Hello world!#",
	"C51 Regards!#",
	"Let's do this!#",
	"123456789ABXYZ#"
};

void send(){            // 数据发送程序
	TH1 = 0xf4;                          // 波特率为2400
	TL1 = 0xf4;
	TR1 = 1;                             // 启动定时器T1（T1作波特率的发生器）
	FLAG = 0;
	if (buf_ptr >= 20){
		sendBuffer[19] = '#';			// 终止符
	}
	else {
		sendBuffer[buf_ptr] = '#';
	}
	for (buf_ptr = 0; buf_ptr < 20; buf_ptr ++){
		delayMs(80);
		if (sendBuffer[buf_ptr] <= 10){
			break;
		}
		else{
			SBUF = sendBuffer[buf_ptr];
			while(TI == 0);                       // 若发送中断标志位没有置1(正在发送数据)，就等待
			TI = 0;                               // 若发送完成，TI自动置1，这里把它清零
		}
		if (sendBuffer[buf_ptr] == '#'){
			break;
		}
	}
	TI = 0;
	TR1 = 0;
	FLAG = 1;
	counter++;
	if (counter >= 10){
		counter = 0;
	}
	P1 = counter;
}

void bufferInput(uchar dat){
	if (buf_ptr < 20){
		sendBuffer[buf_ptr++] = dat;
	}
}

void bufferReset(){
	for (buf_ptr = 0; buf_ptr < 20; buf_ptr ++){
		sendBuffer[buf_ptr] = '\0';
	}
	buf_ptr = 0;
}

void bufferPop(){
	if (buf_ptr > 0){					// buf 始终指向下一个要填入的位置，和栈类似
		buf_ptr --;
		sendBuffer[buf_ptr] = '\0';
	}
}

void publisherInit(){
	TMOD = 0x20;                         // 定时器T1工作于方式2（可自动重装的8位定时器）
	SCON = 0x40;                         // 串口工作方式1，不允许接收
	PCON = 0x00;
	TH1 = 0xf4;                          // 波特率为2400
	TL1 = 0xf4;
	TR1 = 1;                             // 启动定时器T1（T1作波特率的发生器）
	FLAG = 1;							 // 外部中断是下降沿触发
	T0 = 0;
}
```

```C
#include "serial_talk.h"
#include "keyboard_module.h"

void main(){
	uint pos, old_pos = 40;
	P1 = 0x00;
	publisherInit();
	while(1) {
		if (T0 == 0){
			pos = sweepingScan();
			if (pos != 40 && pos == old_pos){
				continue;
			}
			if (pos < 40){
				keyboardEvent(pos);
			}
			delayMs(10);
			old_pos = pos;
		}
	}
}
```

---

#### 5.2 设计二

##### 5.2.1 原理图

![](C:\Users\15300\Desktop\数电实验\电子线路设计\d2.JPG)

##### 5.2.2 代码

```c
/**
 * ================= LCD显示模块 ====================
 * @brief LCD 20x4 函数定义以及相关宏
 * @date 2020.10.4
 * @author 何千越
*/

#ifndef __DISPLAY_MODULE_H__
#define __DISPLAY_MODULE_H__

#include <reg52.h>
#include "utils.h"
#include "stack_module.h"
#include "sensor_module.h"
#include "append_module.h"

#define DELAY 1

// ================ LCD宏 ===================//
#define INITIAL 			0x38
#define CLA 				0x01
#define DISPLAY_START 		0x80

#define CURSOR_BLINK 		0x0f
#define CURSOR_NON_BLINK 	0x0e
#define SHOW_CURSOR 		0x0d
#define NO_CURSOR 			0x0c
#define CURSOR_FORWARD 		0x06
#define CURSOR_BACKWARD 	0x04
#define DISPLAY_LEFT 		0x07
#define DISPLAY_RIGHT 		0x05
#define CURSOR_LEFT 		0x10
#define CURSOR_RIGHT 		0x14
#define ALL_LEFT 			0x18
#define ALL_RIGHT 			0x1c


sbit RS = P2 ^ 0;
sbit RW = P2 ^ 1;
sbit EN = P2 ^ 2;

extern uchar now_row;		// 当前光标行
extern uchar now_col;		// 当前光标列
extern uchar head_row;		// 当前屏幕上字符最大达到的行
extern uchar head_col;		// 当前屏幕上字符最大达到的列

extern uchar buffer[24];	// 输入缓冲区
extern uint _temp;			// 温度记录
extern bit use_cel;			// 使用摄氏度显示
extern bit tobe_reset;		// 在等号按下后，重新输入需要清零

/// 设置中包括：是否打开按键与闹钟指示灯？是否静音？是否开启科学计数法显示？（最后一个最难）

void Init();				// 初始化

/// ================== 七个按键函数 =====================
void doPop();				// 行尾删除
void allClear();			// 清空
void settings();			// 设置
void mainMenu();			// 主菜单
void yieldResult();			// 等号操作
void moveLeft();			// 光标左移
void moveRight();			// 光标右移

void writeCursor(uchar _data);	// 光标边界检测 + 输入
void write(uchar _dat, bit data_flag);		// 简单写入
void writeLine(uchar* ptr, uint line, bit clear, uchar align);		// 写入列
void setCursor(uchar row, uchar col);
uchar checkBusy();

void drawSettings();
void drawMainMenu();
void drawError(uchar err);
void drawTemperature(bit skip);
void drawAlarmUI(bit skip);
void alarmingEffect();
void drawSuspend();
#endif 	//__DISPLAY_MODULE_H__
```

```c
#include "display_module.h"

uchar now_row = 1;
uchar now_col = 0;
uchar head_row = 1;
uchar head_col = 0;
uint _temp = 25;

bit tobe_reset = 0;
uchar buffer[24];
bit use_cel = 1;			// 使用摄氏度显示

void Init(){
	write(INITIAL, 0);
	write(CLA, 0);
	write(SHOW_CURSOR, 0);
	write(CURSOR_FORWARD, 0);
	write(CURSOR_BLINK, 0);
	allClear();
}

uchar busyCheck()   //忙检查
{
  uchar	status;
  RS = 0;	 
  RW = 1;	 
  EN = 1;	 
  delayMs(DELAY);
  status = P0; 	//读出P0最高位状态值
  EN = 0;
  return status;
}

/// 写入数据或者指令
void write(uchar _data, bit data_flag){
	while((busyCheck()&0x80) == 0x80);
	RW = 0;
	RS = data_flag;		// data_flag为1时为写入数据
	EN = 0;
	delayMs(DELAY);
	EN = 1;
	P0 = _data;
	delayMs(DELAY);
	EN = 0;				// 约2 * DELAY ms的脉冲
}

// 在行尾补充
void writeCursor(uchar _data){
	if ((now_row != head_row) || (now_col != head_col)){		// 存在光标不与最大位置对齐时，只改变当前位置
		if (now_col < 19){
			write(_data, 1);
			buffer[(now_row - 1) * 20 + now_col] = _data;
			now_col ++;
		}
		else{
			if (now_row == 1){
				write(_data, 1);
				buffer[(now_row - 1) * 20 + now_col] = _data;
				setCursor(2, 0);		// 光标位置改变到下一行
				now_col = 0;
				now_row = 2;
			}
		}
	}
	else{								// 光标未对齐时只更改当前位置上的字符，不会影响最大长
		if (head_col < 19){
			write(_data, 1);
			buffer[(head_row - 1) * 20 + head_col] = _data;
			buffer[(head_row - 1) * 20 + head_col] = _data;
			head_col ++;
			now_col = head_col;
		}
		else{
			if (head_row == 1){
				write(_data, 1);
				buffer[(head_row - 1) * 20 + head_col] = _data;
				setCursor(2, 0);		// 光标位置改变到下一行
				head_col = 0;
				head_row = 2;
				now_row = head_row;
				now_col = head_col;
			}
		}
	}
}

void writeLine(uchar* ptr, uint line, bit clear, uchar align){
	uint index;
	uchar start_pos = 0;
	switch(align){
		case CENTRAL:
			start_pos = (uchar)((20 - strlen(ptr)) / 2); break;
		case LEFT:
			break;
		case RIGHT:
			start_pos = (uchar)(20 - strlen(ptr)); break;
		default:
			break;
	}
	if (clear == 0){
		write(DISPLAY_START + line_offset[line] + start_pos, 0);
		for (index = 0; index < 20 && ptr[index] >= 10; index++){
			write(ptr[index], 1);
		}
	}
	else{
		write(DISPLAY_START | line_offset[line], 0);
		for (index = 0; index < start_pos; index ++){
			write(0x20, 1);
		}
		for (index = 0; index < 20 && ptr[index] >= 0x0a; index ++){
			write(ptr[index], 1);
		}
		for (; index < 20 - start_pos; index ++){
			write(0x20, 1);
		}
	}
}

//========================光标移动（包括写入/删除/左右移位）==========================

void setCursor(uchar row, uchar col){
	write(DISPLAY_START + line_offset[row] + col, 0);
}

/// 编号0 @brief删除行末字符
void doPop(){
	if (_mode){
		return;
	}
	if ((now_row != head_row) || (now_col != head_col)){
		now_row = head_row;
		now_col = head_col;
		setCursor(head_row, head_col);
	}
	if (head_col != 0){
		head_col --;
		now_col --;
		write(CURSOR_LEFT, 0);		// 光标移动到末尾字符上	
		write(' ', 1);				// 清除
		write(CURSOR_LEFT, 0);		// 由于光标一直采取右移的方式，写入以后会右移一位，则需要左移
		buffer[(head_row - 1) * 20 + head_col] = 0;
	}
	else{
		if (head_row > 1){
			head_row = 1;
			head_col = 19;
			now_row = head_row;
			now_col = head_col;
			setCursor(1, 19);
			write(' ', 1);
			setCursor(1, 19);		// 跨行删除时，由第二行到第一行先退回光标，再删除，再移动光标到第二行行首
			buffer[(head_row - 1) * 20 + head_col] = 0;
		}
	}
}

/// 编号1 @brief AC @todo 此后需要增加：清除栈内所有内容
void allClear(){
	int i;
	write(CLA, 0);
	head_row = 1;
	head_col = 0;
	now_row = head_row;
	now_col = head_col;
	if (alarm_time == ALARM_OFF){
		writeLine(alarm_info[4], 0, 1, CENTRAL);
	}
	else{
		writeLine(alarm_info[5], 0, 1, CENTRAL);
	}
	write(SHOW_CURSOR, 0);
	setCursor(1, 0);
	_mode = CALC;
	for (i = 0; i < 24; i++){
		*(buffer + i) = 0;
	}
	suspend_lock = 0;
}


/// 编号2 @brief 进入设置模式
void settings(){
	allClear();
	write(NO_CURSOR, 0);		// 关闭光标
	writeLine("***** Settings *****", 0, 0, LEFT);
	_mode = SETS;
	drawSettings();
}

/// 编号3 @brief 进入主菜单
void mainMenu(){
	allClear();
	write(NO_CURSOR, 0);		// 关闭光标
	writeLine("******* Menu *******", 0, 0, LEFT);
	_mode = MENU;
	drawMainMenu();
}

/// 编号4 @brief 等号操作 （在设置以及主菜单中表示确定或者更改）
void yieldResult(){
	uchar result, err, buf[3];
	if (_mode == 0){
		setCursor(head_row, head_col);
		if ((head_row - 1) * 20 + head_col > 21){
			drawError(0x02);			// 栈溢出
		}
		err = stackInput(buffer, &result);
		if (err != 0x03){
			drawError(err);
		}
		else{
			buf[0] = (uchar)(result / 100) + 48;
			buf[1] = (uchar)((result - (buf[0] - 48) * 100) / 10) + 48;
			buf[2] = result % 10 + 48;
			writeLine(buf, 3, 1, RIGHT);
			tobe_reset = 1;
		}
	}
	else if(_mode < MENU){
		sets[_mode - 1] = 1 - sets[_mode - 1];
		LED_OUTPUT = 1 - sets[2];
		drawSettings();
	}
	else if (_mode < IN_SENSOR){
		
		switch(_mode){
			case MENU: 
				allClear();
				_mode = CALC; break;
			case TEMP_SENSOR:
				allClear();
				write(NO_CURSOR, 0);
				_mode = IN_SENSOR;
				_temp = getTempResult();
				use_cel = 1; 
				drawTemperature(0);
				break;
			case ALARM_SET: 
				_mode = IN_ALARM;
				drawAlarmUI(0);					// 0 标识不跳过，兼有初始化以及绘制初始UI的功能
			break;								///@todo 
		}
	}
	else if(_mode == IN_ALARM){
		TR0 = 1;
		allClear();								// 设置成功
	}
}

/// 编号5 @brief 左向移动光标 （在设置以及主菜单中表示上移）
void moveLeft(){
	if (_mode == CALC){
		if (now_col > 0){
			now_col --;
			write(CURSOR_LEFT, 0);
		}
		else {
			if (now_row > 1){
				now_row = 1;
				now_col = 19;
				setCursor(1, 19);
			}
		}
	}
	else if (_mode < MENU){
		_mode = (_mode + 1) % 3 + 1;
		drawSettings();
	}
	else if (_mode < IN_SENSOR){
		_mode = (_mode + 1) % 3 + 4;
		drawMainMenu();
	}
	else if (_mode == IN_SENSOR){						// 7 为传感器温度显示	8 为闹钟调整
		_temp = getTempResult();
		use_cel = !use_cel;			// 切换摄氏度华氏度转换
		drawTemperature(1);
	}
	else {
		second_set = ~second_set;
		drawAlarmUI(1);
	}
}

/// 编号6 @brief 右向移动光标 （在设置以及主菜单中表示下移）
void moveRight(){
	if (_mode == CALC){
		if (now_row == head_row && now_col >= head_col){			// 不可以右移
			return;
		}
		if (now_col < 19){
			now_col ++;
			write(CURSOR_RIGHT, 0);
		}
		else {
			if (now_row < 2){
				now_row = 2;
				now_col = 0;
				setCursor(2, 0);
			}
		}
	}
	else if (_mode < MENU){
		_mode = (_mode) % 3 + 1;
		drawSettings();
	}
	else if (_mode < IN_SENSOR){
		_mode = (_mode) % 3 + 4;
		drawMainMenu();
	}
	else if (_mode == IN_SENSOR){
		_temp = getTempResult();
		use_cel = !use_cel;
		drawTemperature(1);
	}
	else {
		second_set = ~second_set;
		drawAlarmUI(1);
	}
}

void drawMainMenu(){
	uint i;
	for (i = 0; i < 3; i++){
		writeLine(menuItems[i], i + 1, 1, LEFT);
		if (i + 4 == _mode){
			writeLine("<<<", i + 1, 0, RIGHT);
		}
	}
}

void drawSettings(){
	uint i;
	for (i = 0; i < 3; i++){
		writeLine(settingItems[i], i + 1, 1, LEFT);
		if (i + 1 == _mode){
			if (sets[i] == 0){
				writeLine(" OFF <<<", i + 1, 0, RIGHT);
			}
			else {
				writeLine(" ON <<<", i + 1, 0, RIGHT);
			}
		}
		else{
			if (sets[i] == 0){
				writeLine(" OFF ", i + 1, 0, RIGHT);
			}
			else {
				writeLine(" ON ", i + 1, 0, RIGHT);
			}
		}
	}
}

void drawError(uchar err){
	allClear();
	writeLine("********************", 0, 0, LEFT);
	writeLine(errors[err], 1, 1, CENTRAL);
	writeLine("********************", 2, 0, LEFT);
	delayMs(1500);
	allClear();
}

void drawTemperature(bit skip){
	uchar temp_str[4];
	if (skip == 0){
		writeLine(temp_info[0], 0, 1, LEFT);
		writeLine(temp_info[1], 3, 1, LEFT);
	}
	if (_temp > 30){
		writeLine(describe[0], 2, 1, CENTRAL);
	}
	else if (_temp > 20){
		writeLine(describe[1], 2, 1, CENTRAL);
	}
	else if (_temp > 10){
		writeLine(describe[2], 2, 1, CENTRAL);
	}
	else {
		writeLine(describe[3], 2, 1, CENTRAL);
	}
	tempDisplay(_temp, use_cel, temp_str);
	if (use_cel == 1){
		writeLine(temp_info[2], 1, 1, LEFT);		// 摄氏度输出
		
	}
	else{
		writeLine(temp_info[3], 1, 1, LEFT);		// 华氏度输出
	}
	writeLine(temp_str, 1, 0, RIGHT);
}

void drawAlarmUI(bit skip){			// 绘制闹钟设置界面（skip 跳过某些冗余绘制）
	uchar i, astr[10];
	if (skip == 0){
		alarmReset(6);
		for (i = 0; i < 4; i++){
			writeLine(alarm_ui[i], i, 1, LEFT);
		}
		TR0 = 0;
	}
	getAlarmString(astr);
	writeLine(astr, 2, 0, RIGHT);
}

void alarmingEffect(){
	uchar i;
	for (i = 0; i < 4; i++){
		writeLine(alarm_info[i], i, 1, CENTRAL);
	}
	/// @todo
	playSound();
	delayMs(2000);
	allClear();
}

void drawSuspend(){
	uchar i;
	for (i = 0; i < 3; i++){
		writeLine(suspend_ui[i], i, 1, CENTRAL);
	}
	writeLine(suspend_ui[0], 3, 1, CENTRAL);
}
```

```c
/**
 * ================= 键盘模块 ====================
 * @brief LCD 4 * 6 矩阵键盘模块
 * @date 2020.10.5
 * @author 何千越
*/

#ifndef __KEYBOARD_MODULE_H__
#define __KEYBOARD_MODULE_H__
#include <reg52.h>
#include "utils.h"

sbit KEY0 = P2 ^ 6;
sbit KEY1 = P2 ^ 7;
sbit KEY2 = P3 ^ 0;
sbit KEY3 = P3 ^ 1;

extern uchar code charTable[24];

uint sweepingScan();
void keyboardEvent(uint pos);

#endif 	//__KEYBOARD_MODULE_H__
```

```C
#include "display_module.h"
#include "keyboard_module.h"

uchar code charTable[24] = {
	'7', '8', '9', '+', 0, 1,
	'4', '5', '6', '-', '(', ')',
	'1', '2', '3', 'x', 2, 3,
	'.', '0', 4, '/', 5, 6, 
};

uint sweepingScan(){
	int i;
	uchar res = 0x00;
	for (i = 0; i < 4; i++){
		switch(i){
			case 0:
				KEY0 = 0;
				KEY1 = 1;
				KEY2 = 1;
				KEY3 = 1; break;
			case 1:
				KEY0 = 1;
				KEY1 = 0;
				KEY2 = 1;
				KEY3 = 1; break;
			case 2:
				KEY0 = 1;
				KEY1 = 1;
				KEY2 = 0;
			    KEY3 = 1; break;
			default:
				KEY0 = 1;
				KEY1 = 1;
				KEY2 = 1;
			    KEY3 = 0;
		}
		res = P1 & 0xfc;				// 只取取高6位
		if (res != 0xfc){				// P3 第四位变0后的结果如果为0b1111 0000 说明没有对应键盘响应
			switch (res){
				case 0xf8: return 6 * i;
				case 0xf4: return 6 * i + 1;
				case 0xec: return 6 * i + 2;
				case 0xdc: return 6 * i + 3;
				case 0xbc: return 6 * i + 4;
				case 0x7c: return 6 * i + 5;
			}
		}
	}
	return 24;			// 没有键盘事件
}

void keyboardEvent(uint pos){
	uchar ch;
	ch = charTable[pos];
	if (ch > 10){
		if (_mode == IN_ALARM){
			if (ch == '+'){
				alarmSet(1);
				drawAlarmUI(1);		// 更新一次LCD闹钟设置显示
			}
			else if (ch == '-'){
				alarmSet(0);
				drawAlarmUI(1);		// 更新一次LCD闹钟设置显示
			}
			return;
		}
		writeCursor(ch);
	}
	else{
		if (_mode == SUSPEND){
			if (ch == CLA)
				allClear();
			return;
		}
		switch(ch){
			case 0: doPop(); break;
			case 1: allClear(); break;
			case 2: settings(); break;
			case 3: mainMenu(); break;
			case 4: yieldResult(); break;
			case 5: moveLeft(); break;
			case 6: moveRight(); break;
		}
	}
}
```

```c
/**
 * ================= 温度传感器模块 ====================
 * @brief Temperature Sensor DS018B20 函数定义以及相关宏
 * @date 2020.10.11
 * @author 何千越
*/
#ifndef __SENSOR_MODULE_H__
#define __SENSOR_MODULE_H__
#include "utils.h"
#include<intrins.h>

sbit Bus = P3 ^ 7; // 数据单总线

uint getTempResult();				// 返回最终结果
uint getTemp();						// 获取温度子函数
bit sensorReset();					// 初始化子函数
uchar readFromSensor();				// 用于从总线读值
void sensorInit();					// 初始化，设置精度以及范围
void tempConvert();					// 开始转换温度
void writeInSensor(uchar dat);		// 用于向总线写命令
void delay10us(uint t);				// 延时10*t微秒

#endif 	//__SENSOR_MODULE_H__
```

```C
#include "sensor_module.h"

/// ds18b20 10*t延时函数
void delay10us(uint t){
    uint i;
    for(i = t; i > 0; i --){		// 一个_nop_空指令函数延时 1us，加上for循环有10us
        _nop_();
		_nop_();
        _nop_();
    }
}

void sensorInit(){
	sensorReset();
	delayMs(1);
	writeInSensor(0xcc);		// 跳过ROM	
	writeInSensor(0x4e);		// 写EEPROM寄存器
	writeInSensor(0x5f);		// 最高温度95度
	writeInSensor(0x00);		// 最低温度设置为0
	writeInSensor(0x1f);		// 最低精度设置0.5（高位奇数）（100ms内完成转化）
}

/// ds18b20初始化
bit sensorReset(){
	bit ack;
	Bus = 0;
	delay10us(60);	// 最小480，最大960
	Bus = 1;
	delay10us(6);	// 15-60us
	while(Bus == 0);
	Bus = 1;		// 让传感器释放总线，避免影响下一步
	return ack;		// ack为0则响应成功 实际不需判定
}

/// ds18b20写时序
void writeInSensor(uchar dat){		// 一个写周期为60-120us，主机在15--45us内对信号采样
	uchar mask;
	for(mask = 0x01; mask != 0; mask <<= 1){
		Bus = 0;
		_nop_();
		if((mask & dat) == 0){
			Bus = 0;
		}
		else{
			Bus = 1;
		}
		delay10us(6);//15-60us采样
		Bus = 1;
		_nop_();
		_nop_();
	}
}


/*ds18b20读时序*/
uchar readFromSensor(){
	uchar dat = 0;
	uchar mask, fmask;
	for(mask = 0x01; mask != 0; mask <<= 1){	// 一个周期需要至少60us，但采样要在15us内完成
		Bus = 0;
		_nop_();
		Bus = 1;
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		if(Bus == 0){		// 读0
			fmask = ~mask;
			dat = dat & fmask;
		}
		else{
			dat |= mask;
		}
		delay10us(5);
		Bus = 1;
	}
 return dat;
}


/// 转换温度子函数
void tempConvert(){
	sensorReset();
	delayMs(1);
	writeInSensor(0xcc);		// 跳过ROM寻址
	writeInSensor(0x44);		// 启动一次温度转换
}


/// ds18b20获取温度
uint getTemp(){
	uint temp = 0;
	uchar LSB, MSB;				// 用来储存数据的第八位与高八位
	sensorReset();
	delayMs(1);
	writeInSensor(0xcc);		// 跳过寻址
	writeInSensor(0xbe);		// 发送读值命令
	LSB = readFromSensor();
	MSB = readFromSensor();
	temp = MSB;
	temp <<= 8;
	temp |= LSB;
	return temp;
}


/*ds18b20  返回最终结果子函数*/
uint getTempResult(){
	float tp;
	uint temp;
	delayMs(10);		// 10ms度过不稳定期
	tempConvert();		// 转换温度
    delayMs(120);		// 120ms 转化期
    temp = getTemp();
    tp = temp;
    temp = tp * 0.0625;
    return temp;		// 最终结果为temp
}
```

```C
/**
 * ================= 其余模块 ====================
 * @brief 实现功能有：闹钟设置，45s定时关机
 * @date 2020.10.13
 * @author 何千越
*/
#ifndef __APPEND_MODULE_H__
#define __APPEND_MODULE_H__
#include "utils.h"


#define ALARM_OFF 0xffff
#define TH0_START 76
#define TL0_START 208
#define AUTO_SUSPEND 15

sbit LED_OUTPUT = P2^5;		// LED 灯输出
sbit SPEAKER = P2^3;		// 扬声器

extern bit second_set;
extern uint alarm_time;
extern uint now_s;
extern uchar now_ms;
extern uchar toneLow;
extern uchar toneHigh;

void getAlarmString(uchar* str);
void alarmSet(bit add);
void alarmReset(uint atime);

void melody(uchar time);
void playSound();
void halfBeat(uchar t);
void pressingSound();
#endif 	//__APPEND_MODULE_H__
```

```C
#include "append_module.h"

uint now_s = 0;
uchar now_ms = 0;
uchar toneHigh, toneLow;
uint alarm_time = ALARM_OFF;			// 闹钟时间
bit second_set = 1;					// 秒数设置

void alarmReset(uint atime){	// 闹钟重置（定时器关闭，中断关闭，计数重置）
	alarm_time = atime;
	now_s = 0;
	now_ms = 0;
	TH0 = TH0_START;
	TL0 = TL0_START;
	second_set = 1;
}

void alarmSet(bit add){
	if (add == 1){
		if (second_set == 0 && alarm_time < ALARM_MAX - 59){
			alarm_time += 60;
		}
		else if(second_set == 1 && alarm_time < ALARM_MAX){
			alarm_time ++;
		}
	}
	else {
		if (second_set == 0 && alarm_time > 59){
			alarm_time -= 60;
		}
		else if(second_set == 1 && alarm_time > 0){
			alarm_time --;
		}
	}
}

/// @param 输出10位数字 [00]m 00s(\0)
void getAlarmString(uchar* str){
	uchar minute, second;
	minute = alarm_time / 60;
	second = alarm_time % 60;
	if (second_set == 1){
		str[0] = ((uchar)(minute / 10) + 48);
		str[1] = minute % 10 + 48;
		str[2] = 'm';
		str[3] = ' ';
		str[4] = '[';
		str[5] = ((uchar)(second / 10) + 48);
		str[6] = second % 10 + 48;
		str[7] = ']';
	}
	else{
		str[0] = '[';
		str[1] = ((uchar)(minute / 10) + 48);
		str[2] = minute % 10 + 48;
		str[3] = ']';
		str[4] = 'm';
		str[5] = ' ';
		str[6] = ((uchar)(second / 10) + 48);
		str[7] = second % 10 + 48;
	}
	str[8] = 's';
	str[9] = 0;
}

// 定时器中断1
void timerT0() interrupt 1
{
	TH0 = TH0_START;
	TL0 = TL0_START;
	now_ms ++;
	if (now_ms >= 20){
		now_ms = 0;
		now_s ++;
	}
	if (now_s > AUTO_SUSPEND && alarm_time == ALARM_OFF && sets[0] == 1){	// 超过挂起时间，不存在闹钟，自动挂起设置1
		_mode = SUSPEND;			// 自动挂起
		return;
	}
	if (alarm_time != ALARM_OFF && now_s >= alarm_time){		// 超过闹钟时间，存在闹钟设置
		_mode = ALARMING;		
	}
}

/// @brief 蜂鸣器方波输出
void rectWave() interrupt 3
{
	TR1 = 0;
	SPEAKER =! SPEAKER;
	TH1 = toneHigh;
	TL1 = toneLow;
	TR1 = 1;
}

void halfBeat(uchar t){
	uchar t1;
	uint t2;
	for(t1 = 0; t1 < t; t1++){
		for(t2 = 0; t2 < 16000; t2++){
			;
        }
	}
	TR1 = 0;
}

void melody(uchar time){
	TR1= 1;
	halfBeat(time);                      
}

void playSound(){
	uchar i, k, time;
	for (i = 0; i < 84; i += 3){
		k = song[i] + 7 * song[i + 1] - 1;
		toneHigh = FREQH[k];
		toneLow = FREQL[k];
		time = song[i + 2];
		melody(time);
	}
	TR1 = 0;
}

void pressingSound(){		// 按键音
	uchar time;
	toneHigh = 242;
	toneLow = 66;
	time = 3;
	melody(time);
	TR1 = 0;
}
```

```C
/**
 * ================= 公用函数以及类型 ====================
 * @date 2020.10.4
 * @author 何千越
*/
#ifndef __UTILS_H__
#define __UTILS_H__

#include <reg52.h>
#define uint unsigned int
#define uchar unsigned char
	

// =============== 其他宏 ================== //
#define CENTRAL 0
#define LEFT	1
#define RIGHT	2
#define CALC	0			// 系统模式
#define SETS	1			// 1为 指示灯 2为按键音 3为科学计数法显示
#define MENU	4			// 4为计算模式	5为温度显示  6为闹钟设置
#define TEMP_SENSOR	5		// 温度传感器待选
#define ALARM_SET	6		// 闹钟待选
#define IN_SENSOR	7		// 温度传感器界面内部
#define IN_ALARM	8		// 闹钟设置界面内部
#define ALARMING	9		// 闹钟正在响
#define SUSPEND		0xff	// 挂起模式

#define ALARM_MAX 3599		// 最大可以设置59分59秒

extern uchar _mode;			// 当前模式 @todo 普通计算模式，温度/电量显示模式，闹钟设置（计时器中断打开/关闭？）
extern bit suspend_lock;
extern uchar sets[3];		// 设置
	
// 行偏移
extern uchar code line_offset[4];

extern uchar code menuItems[3][20];

extern uchar code settingItems[3][20];

extern uchar code errors[3][20];

extern uchar code temp_info[4][20];

extern uchar code describe[4][12];

extern uchar code alarm_info[6][20];

extern uchar code alarm_ui[4][20];

extern uchar code suspend_ui[3][20];

extern uchar code FREQH[28];

extern uchar code FREQL[28];

extern uchar code song[84];

int strlen(uchar* ptr);

void delayMs(uint ms);

void tempDisplay(uint temp, bit celc, uchar* str);

#endif 	//__UTILS_H__
```

```C
#include "utils.h"

uchar _mode = 0;					// 主要模式
bit suspend_lock = 0;				// 挂起绘制锁
uchar sets[3] = {0, 0, 0};			// 设置（45秒自动挂起，按键音，键盘灯）

uchar code line_offset[4] = {
	0x00, 0x40, 0x14, 0x54
};

uchar code menuItems[3][20] = {
	"# Calculation",
	"# Sensors",
	"# Alarm Setting"
};

uchar code settingItems[3][20] = {
	"45s suspend:",					// 45 秒自动挂起
	"Press sound:",					// 按键音
	"LED Light:"					// 键盘灯
};

uchar code errors[3][20] = {
	"Syntax Error",
	"Math Error",
	"Stack Error"
};

uchar code temp_info[4][20] = {
	"Current Temperature",
	"* * * * ** * * * * *",
	"Celcius:",
	"Fahrenheit:"
};

uchar code describe[4][12] = {
	"Damn hot",
	"Suitable",
	"Brisk!",
	"Freezing"
};

uchar code alarm_info[6][20] = {
	"=====Time is Up=====",
	"Press AC to turn off",
	"Song:[So Far Away]",
	"====================",
	"----- NO ALARM -----",
	"----- ALARM ON -----"
};

uchar code alarm_ui[4][20] = {
	"***Set your alarm***",
	"Upper bound: 59m 59s",
	"Set:",
	"********************"
};

uchar code suspend_ui[3][20] = {
	"********************",
	"*    SUSPENDING    *",
	"*   POWER SAVING   *"
};

uchar code FREQH[28] = {
    248, 247, 246, 245, 245, 243, 242,
    252, 252, 251, 251, 250, 250, 249, 249,
    254, 253, 253, 253, 253, 252,   
    255, 254, 254, 254, 254, 254, 254,
};

uchar code FREQL[28] = {
    182, 209, 208, 182, 23, 193, 66,
    143, 91, 233, 104, 216, 140, 225, 33,
    45, 244, 180, 107, 68, 238, 
    22, 250, 218, 182, 162, 119, 71,
};// 音阶频率表 低八位

//uchar code song[75] = {
//         5,1,1, 5,1,1, 6,1,2, 5,1,2, 1,1,2, 5,1,4,
//         5,1,1, 5,1,1, 6,1,2, 5,1,2, 2,1,2, 1,1,4,
//         5,1,1, 5,1,1, 5,0,2, 3,1,2, 1,1,2, 5,1,2, 5,1,2,
//         4,1,1, 4,1,1, 3,1,2, 1,1,2, 2,1,2, 1,1,4
//};

uchar code song[84] = {
	2, 1, 2,	3, 1, 2,	6, 0, 2, 	1, 1, 4,	6, 0, 2, 	5, 1, 2, 	5, 1, 1, 	2, 1, 1, 	
	1, 1, 2, 	5, 1, 2,	5, 1, 1, 	2, 1, 4, 	1, 1, 2, 	6, 0, 1, 	1, 1, 1, 	6, 0, 1,
	2, 1, 2,	3, 1, 2,	6, 0, 2, 	1, 1, 4,	6, 0, 2, 	5, 1, 2, 	5, 1, 1, 	2, 1, 1,
	7, 0, 2, 	6, 0, 1, 	2, 1, 1, 	1, 1, 4
};

int strlen(uchar* ptr){
	int i = 0;
	while(i < 20){
		if (ptr[i] < 0x0a){
			return i;
		}
		i++;
	}
	return 20;
}

void delayMs(uint ms){
	int i, j;
	for (i = ms; i > 0; i--){
		for (j = 110; j > 0; j--){
			;
		}
	}
}

/// str 的长度为4，三位的有效数字 + 一位的华氏度摄氏度指示
void tempDisplay(uint temp, bit celc, uchar* str){
	int i;
	uchar now, cnt = 0;
	if (celc == 0){
		temp = temp * 9 / 5 + 32;		// 转为华氏度
	}
	for (i = 100; i > 0; i /= 10){
		now = temp / i;
		temp -= now * i;
		str[cnt] = (now + 48);
		cnt ++;
	}
	if (celc == 1){
		str[cnt] = 'C';
	}
	else {
		str[cnt] = 'F';
	}
}
```

```C
#include "display_module.h"
#include "keyboard_module.h"


void main(){
	uint pos, old_pos = 24;
	// ================= 中断设置 =====================
	TMOD = 0x01;		// 16位定时器
	ET0 = 1;			// 定时器中断 打开定时器中断ET1
	ET1 = 1;			
	EA = 1;
	TR0 = 1;				// 定时器打开
	
	
	Init();
	sensorInit();
	_mode = SUSPEND;	// 开始时挂起
	while(1){
		pos = sweepingScan();
		if (pos != 24 && pos == old_pos){
			continue;
		}
		if (pos  < 24){
			if (tobe_reset == 1 && pos != 5){		// 如果本来就按下AC键就没必要再清除一次
				allClear();
				tobe_reset = 0;
			}
			if (alarm_time == ALARM_OFF){	// 没有闹钟时，每次有按键事件都会刷新定时
				now_s = 0;
				now_ms = 0;
			}
			if (sets[1] == 1){
				pressingSound();
			}
			keyboardEvent(pos);
		}
		if (_mode == ALARMING){				
			alarmReset(ALARM_OFF);		// 闹钟显示功能不能使用中断实现（产生复入问题）
			alarmingEffect();			// 闹钟结束后，自动设为计算模式
		}
		else if(_mode == SUSPEND && suspend_lock == 0){
			suspend_lock = 1;
			drawSuspend();
		}
		delayMs(10);
		old_pos = pos;
	}
}
```

---

### VI. 软件/硬件/教学支持

- 报告编写 Typora [with Markdown]
- 流程图绘制 XMind ZEN
- 电路设计与代码实现 Proteus / Keil C51
- 感谢老师的指导与建议